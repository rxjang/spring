# 4.2 예외 전환
`DateAccessException`으로 예외 전환한 이유
* 복구가 불가능한 예외인 `SQLException`에 대해 애플리케이션 레벨에서는 신경 쓰지 않도록 해줌
* `SQLException`에 담긴 다루기 힘든 상세한 예외 정보를 의미있고 일관성 있는 예외로 전환해서 추상화 해줌

## 4.2.1 JDBC의 한계
JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해 놓고, 각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해준다.  
하지만 현실적으로 DB를 자유롭게 바꾸어 사용할 수 있는 DB 프로그램을 작성하는 데는 두 가지 걸림돌이 있다. 

### 비표준 SQL
대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능도 제공한다. 어쩔 수 없이 비표준으로 작성된 SQL은 DAO로 들어가게 되고, 해당 DAO는 특정 DB에 대해 종속적인 코드가 되고 만다. 

### 호환성 없는 SQLException의 DB 에러정보
DB마다 에러의 종류와 원인도 제각각이다. 그래서 JDBC는 데이터 처리 중에 발생하는 다양한 예외를 그냥 `SQLException` 하나에 모두 담아버린다. `SQLException`의 `getErrorCode()`로 가져 올 수 있는 DB 에러 코드 또한 DB별로 모두 다르다.  
그래서 `SQLException`은 예외가 발생했을 때의 DB상태를 담은 SQL 상태정보를 부가적으로 제공하는 `getSQLState()`메소드를 제공한다. 이 상태정보는 DB별로 달라지는 에러 코드를 대신할 수 있도록 **Open Group의 XOPEN SQL 스펙에 정의된 SQL 상태 코드를 따르도록 되어 있다.**  
문제는 DB의 JDBC드라이버에서 `SQLException`을 담을 상태 코드를 정확하게 믄들어 주지 않는다는 점이다. 결과적으로 SQL 상태 코드를 믿고 결과를 파악하도록 코드를 작성하는 것은 위험하다. 

## 4.2.2 DB 에러 코드 매핑을 통한 전환
`SQLException`의 비표준 에러 코드와 SQL 상태정보에 대한 해결책을 알아보자.  
`SQLException`에 담긴 SQL 상태 코드는 신뢰할 만한 게 아니다. DB 전용 에러 코드가 더 정확한 정보라고 볼 수 있다. 해결 방법은 DB별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해 주는 기능을 만드는 것이다.  
문제는 DB마다 에러 코드가 제각각이라는 점이다. 스프링은 DB별 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은 에러 코드 매핑정보 테이블을 만들어두고 이를 이용한다.  
`JdbcTemplate`은 `SQLException`을 `DataAccessException`으로 포장하는 것이 아니라 **DB의 에러 코드를 `DataAccessException` 계층구조의 클래스 중 하나로 매핑해준다.**  
중복 키 에러를 따로 분류해서 예외처리를 해줬던 `add()` 메소드를 스프링의 `JdbcTemplate`으로 바꾸면 아래와 같이 간단해 진다. 
``` java
public void add() throw DuplicateKeyException {
    ...
}
```
`JdbcTemplate`이 계층구조의 예외로 포장해주기 때문에 예외 포장을 위한 코드가 따로 필요 없다. 즉, `JdbcTemplate`을 이용한다면 JDBC에서 발생하는 DB관련 예외는 거의 신경 쓰지 않아도 된다.  

## 4.2.3 DAO 인터페이스와 DataAccessException 계층구조
`DataAccessException`은 JDBC 외의 자바 데이터 엑세스 기술에서 발생하는 예외에도 적용된다. `DataAccessException`은 의미가 같은 예외라면 데이터 엑세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어준다. 

### DAO 인터페이스와 구현의 분리
DAO를 사용하는 이유는 데이터 엑세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위해서다. DAO를 사용하는 쪽에서는 DAO가 내부에서 어떤 데이터 엑세스 기술을 사용하는지 신경 쓰지 않아도 된다.  
그런데 DAO의 사용 기술과 구현 코드는 전략 패턴과 DI를 통해서 DAO를 사용하는 클라이언트에게 감출 수 있지만, 메소드 선언에 나타나는 예외정보가 문제가 될 수 있다. JDBC가 아닌 다른 데이터 엑세스 기술로 DAO 구현을 전환하면 사용할 수 없기 때문이다. 데이터 엑세스 기술의 API는 자신만의 독자적인 예외를 던진다.  
가장 간단한 해결 방법은 모든 예외를 다 받아주는 throws Exception으로 선언하는 것이다. 간단하긴 하지만 무책임한 선언이다.  
다행히도 JDBC보다는 늦게 등장한 JDO, Hibernate, JPA등의 기술은 `SQLException`같은 체크 예외 대신 런타임 예외를 사용한다. 따라서 throws에 선언을 해주지 않아도 됟다. 남은 것은 `SQLException`을 던지는 JDBC API를 직접 사용하는 DAO뿐인데, 이 경우에는 DAO메소드 내에서 런타임 예외로 포장해서 던져줄 수 있다.   
이제 DAO에서 사용하는 기술에 환전히 독립적인 인터페이스 선언이 가능해졌다. 하지만 DAO를 사용하는 클라이언트 입장에서는 DAO의 사용 기술에 따라서 예외 처리 방법이 달라져야 한다. 결국 클라이언트가 DAO의 기술에 의존적이 될 수밖에 없다.

### 데이터 액세스 예외 추상화와 DataAccessException 계층 구조
그래서 스프링은 자바의 다양한 테이터 액세스 기술을 사용할 때 발생하는 예외들을 추상화해서 `DataAccessException` 계층구조 안에 정리해놓았다. 
* 자바의 주요 데이터 액세스 기술에서 발생할 수 있는 대부분의 예외를 추상화하고 있음
* 템플릿 메소드나 DAO 메소드에서 직접 활욜 할 수 있는 예외도 정의되어 있음


