# 3.5 템플릿과 콜백
`템플릿` 전략 패턴의 컨텍스트
* 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀
* 고정된 틀 안에 바꿀 수 있는 부분을 넣어서 사용하는 경우

`콜백` 익명 내부 클래스로 만들어지는 오브젝트
* 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트
* 특정 로직을 담은 메소드를 실행시키기 위해 사용

-> 지금 까지의 코드는 일종의 전략 패턴, 특히 `템플릿/콜백` 패턴이 적용 된 것이라 볼 수 있음.

## 3.5.1 템플릿/콜백의 동작원리
### 템플릿/콜백의 특징
`단일 메소드 인터페이스를 사용한다.`
* 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 떄문
* 하나의 템플릿에 여러 가지 종류의 전략을 사용해아 한다면 하나 이상의 콜백 오브젝트를 사용할 수 있음  

`콜백 인터페이스의 메소드에는 보통 파라미터가 있다.`
* 이 파라미터는 템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용됨 

**템플릿/콜백 패턴의 일반적인 작업 흐름**
1. 클라이언트는 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만든다. 
2. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달된다. (메소드 레벨에서 일어나는 DI)
3. 템플릿은 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출한다. 
4. 콜백인 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행한다. 
5. 콜백은 그 겨로가를 다시 탬플릿에 돌려준다.
6. 템플릿은 콜백이 돌려준 정보를 사용해 작업을 마저 수행한다.
7. 경우에 따라 최종 결과를 클라이언트에게 다시 돌려주기도한다.

`매번 메소드 단위로 사용할 오브젝트를 새롭게 전달 받는다.` 
* 일반적인 DI라면 템플릿에 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를 수정자 메소드로 받아서 사용한다. 

`콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다.` 

## 3.5.2 편리한 콜백의 재활용
템플릿/콜백 방식에서 한 가지 아쉬운 점은 DAO 메소드에서 매번 익명 내부 클래스를 사용하기 때문에 상대적으로 코드를 작성하고 읽기가 불편하다는 점이다.

### 콜백의 분리와 재활용
복잡한 익명 내부 클래스의 사용을 최소화할 수 있는 방법을 찾아보자. JDBC의 try/catch/finally에서 적용했던 방법을 현재 `UserDao`의 메소드에도 적용해보자.  
`deleteAll()`을 보면 메소드의 내용을 통틀어서 바뀔 수 있는 부분은 오직 "DELETE FROM users"라는 문자열일 뿐이다. 그렇다면 SQL문장만 파라미터로 받아서 바꿀 수 있게 하고 메소드 내용 전체를 분리해 별도의 메소드로 만들어보자. 
``` java
public void deleteAll() throws SQLException {
    executeSql("DELETE FROM users");
}

public void executeSql(final String query) throws SQLException {
    this.jdbcContext.workWithStatementStrategy(new StatementStrategy() {
        @Override
        public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
            return c.prepareStatement(query);
        }
    });
}
```
이렇게 해서 재활용 가능한 콜백을 담은 메소드가 만들어졌다. 이제 모든 고정된 SQL을 실행하는 DAO 메소드는 `executeSql()`을 호출하면 끝이다.

### 콜백과 템플릿의 결합
한 단계 더 나아가보자. `executeSql()` 메소드는 `UserDao`만 사용하기는 아까우므로 이렇게 재사용 가능한 콜백을 담고 있는 메소드라면 DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨도된다. 즉, `JdbcContext` 클래스로 콜백 생성과 템플릿 호출이 담긴 executeSql() 메소드를 옮기자는 것이다.
``` java
public class JdbcContext {
    ...
    public void executeSql(final String query) throws SQLException {
        this.workWithStatementStrategy(new StatementStrategy() {
            @Override
            public PreparedStatement makePreparedStatement(Connection c) throws SQLException {
                return c.prepareStatement(query);
            }
        });
    }
}
```
``` java
public void deleteAll() throws SQLException {
    this.jdbcContext.executeSql("DELETE FROM users");
}
```
이제 모든 DAO 메소드에서 `executeSql()`를 사용할 수 있게 됐다.  
일반적으로는 성격이 다른 코드들은 가능한 분리하는 편이 낫지만 이 경우는 반대다. **하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 응집력이 강한 코드들이기 때문에 한 군데 모여 있는게 유리하다.**




